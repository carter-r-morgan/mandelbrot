<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mandelbrot</title>

<script type="text/javascript">
	const vertexShader = `
		attribute vec2 renderPos;
		uniform mat3 transform;
		varying vec2 complexPos;

		void main() {
			complexPos = vec2(transform * vec3(renderPos, 1));
			gl_Position = vec4(renderPos, 0, 1);
		}
	`;

	const fragmentShader = `
		precision highp float;

		varying vec2 complexPos;
		const int detail = 20;
		const vec4 black = vec4(0, 0, 0, 1);
		const vec4 c1 = vec4(0, 0, 0, 1);
		const vec4 c2 = vec4(1, 1, 1, 1);

		// Evaluate a point in the complex plane to determine whether it is in
		// the Mandelbrot set. Return the number of iterations it takes for
		// the point to be rejected or -1 if the point is never rejected.
		int evalMandelbrot(vec2 c) {
			vec2 z = c;
			for (int i = 0; i < detail; i++) {
				if (length(z) > 2.0) {
					return i;
				}

				// z[n+1] = z[n]**2 + c
				z = vec2(z.x*z.x - z.y*z.y + c.x, 2.0*z.x*z.y + c.y);
			}

			return -1;
		}

		void main() {
			int iters = evalMandelbrot(complexPos);

			if (iters == -1) {
				gl_FragColor = black;
			}
			else {
				gl_FragColor = mix(c1, c2, float(iters) / float(detail));
			}
		}
	`;

	const positions = [
	  -1.0, -1.0,
	  -1.0,  1.0,
	   1.0, -1.0,
	   1.0,  1.0,
	];

	let canvas, gl, program;

	let zoom = 3;
	let x = 0, y = 0;
	let dragStart = null;

	window.addEventListener("load", init);
	window.addEventListener("resize", render);


	// World -- View -- Clip -- Canvas

	/**
	 * Map some position from canvas-space to view-space.
	 */
	function mapCaV(position) {
		const [X, Y] = position;
		const minDim = canvas.width < canvas.height ? canvas.width : canvas.height;
		return [(X - canvas.width / 2) / minDim * zoom * 2,
		        -(Y - canvas.height / 2) / minDim * zoom * 2];
	}

	/**
	 * Map some position from view-space to world-space.
	 */
	function mapVW(position) {
		const [X, Y] = position;
		return [X + x, Y + y];
	}

	/**
	 * Map some positon from canvas-space (relative to the top-left corner of the canvas) to world-space.
	 */
	function mapCaW(position) {
		return mapVW(mapCaV(position));
	}

	function set(X, Y, Z) {
		x = X;
		y = Y;
		zoom = Z;
		render();
	}

	function init() {
		canvas = document.getElementById("content");
		gl = canvas.getContext("webgl");
		gl.clearColor(1, 1, 1, 0);

		/*********************
		* Add Event Handlers *
		**********************/

		canvas.addEventListener("pointerdown", handlePointerDown);
		canvas.addEventListener("pointermove", handlePointerMove);
		canvas.addEventListener("pointerup", handlePointerUp);
		canvas.addEventListener("pointerleave", handlePointerLeave);
		canvas.addEventListener("wheel", handleWheel);

		/************************************
		 * GL Shader Compilation & Linking. *
		 ************************************/	
		const vs = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vs, vertexShader);
		gl.compileShader(vs);

		if ( ! gl.getShaderParameter(vs, gl.COMPILE_STATUS) ) {
			alert( `Vertex Shader: "${gl.getShaderInfoLog(vs)}"` );
			gl.deleteShader(vs);
		}

		const fs = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fs, fragmentShader);
		gl.compileShader(fs);

		if ( ! gl.getShaderParameter(fs, gl.COMPILE_STATUS) ) {
			alert( `Fragment Shader: "${gl.getShaderInfoLog(fs)}"` );
			gl.deleteShader(fs);
		}
		
		program = gl.createProgram();
		gl.attachShader(program, vs);
		gl.attachShader(program, fs);
		gl.linkProgram(program);

		if ( ! gl.getProgramParameter(program, gl.LINK_STATUS) ) {
			alert( gl.getProgramInfoLog(program) );
		}

		/****************************
		 * Position Attribute Setup *
		 ****************************/	
		const posBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

		const p = gl.getAttribLocation(program, "renderPos");
		gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
		gl.vertexAttribPointer(p, 2, gl.FLOAT, false, 0, 0);
		gl.enableVertexAttribArray(p);

		render();
	}

	function render() {
		/*************************
		 * GL Setup              *
		 * May want to move out. *
		 *************************/
		const pixelRatio = window.devicePixelRatio || 1;
		canvas.width  = pixelRatio * canvas.clientWidth;
		canvas.height = pixelRatio * canvas.clientHeight;
		gl.viewport(0, 0, canvas.width, canvas.height);

		/**********************************
		 * Matrix Transform Uniform Setup *
		 * May need its own function.     *
		 **********************************/
		const [scaleX, scaleY] = mapCaV([canvas.width, 0]);
		let matrix = [
		  scaleX , 0      , 0,
		  0      , scaleY , 0,
		  x      , y      , 1
		];

		const m = gl.getUniformLocation(program, "transform");
		gl.useProgram(program);
		gl.uniformMatrix3fv(m, false, matrix);

		/*****************************
		 * Actually render the scene *
		 *****************************/
		gl.clear(gl.COLOR_BUFFER_BIT);
		gl.useProgram(program);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	}

	/*****************
	* Event Handlers *
	******************/

	function handlePointerDown(e) {
		console.log("down!");
		dragStart = mapCaW([e.offsetX, e.offsetY]);
	}

	function handlePointerMove(e) {
		if (!dragStart) return;

		[startX, startY] = dragStart;
		const [currX, currY] = mapCaW([e.offsetX, e.offsetY]);
		// Move frame so that dragStart is under the clicked point
		x += startX - currX; y += startY - currY;

		render();
	}

	function handlePointerUp(e) {
		console.log("up!");
		dragStart = null;
	}

	function handlePointerLeave(e) {
		console.log("leave!");
		dragStart = null;
	}

	function handleWheel(e) {
		const zoomRatio = Math.pow(4/3, e.deltaY / 100);
		// p is the world-coordinate corresponding to the pointer's position.
		const [pX, pY] = mapCaW([e.offsetX, e.offsetY]);

		// v is the vector from the window's position to p.
		// When the window is zoomed, we want p to remain fixed under the pointer, so we
		// move the window according to the equation: delta = v - zoom*v = (1 - zoom)*v
		const [vX, vY] = [pX - x, pY - y];
		const [dx, dy] = [(1 - zoomRatio)*vX, (1 - zoomRatio)*vY];

		x += dx; y += dy;
		zoom *= zoomRatio
		render();
	}

</script>

<style>
	#content {
		position: absolute;
		width: 100%;
		height: 100%;
	}

	#controls {
		position: absolute;
		top: 1em;
		right: 1em;
	}

	body {
		margin: 0;
	}

</style>
</head>

<body>
	<canvas id="content"></canvas>
	<div id="controls">
		<button onclick="{zoom *= 3/4; render();}">+</button>
		<button onclick="{zoom *= 4/3; render();}">-</button>
	</div>
</body>
</html>