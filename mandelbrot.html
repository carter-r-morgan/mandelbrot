<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mandelbrot</title>

<script type="text/javascript">
	const vertexShader = `
		attribute vec2 renderPos;
		uniform mat3 transform;
		varying vec2 complexPos;

		void main() {
			complexPos = vec2(transform * vec3(renderPos, 1));
			gl_Position = vec4(renderPos, 0, 1);
		}
	`;

	const fragmentShader = `
		precision mediump float;

		varying vec2 complexPos;
		const int detail = 20;
		const vec4 black = vec4(0, 0, 0, 1);
		const vec4 c1 = vec4(0, 0, 0, 1);
		const vec4 c2 = vec4(1, 1, 1, 1);

		void main() {
			float x = complexPos.x;
			float y = complexPos.y;

			int iters;
			for (int i = 0; i < detail; i++) {
				if (sqrt(x*x + y*y) > 2.0) {
					iters = i;
				  break;
				}

				float nextX = x*x - y*y + complexPos.x;
				y = 2.0*x*y + complexPos.y;
				x = nextX;
			}

			if (iters == detail) {
				gl_FragColor = black;
			}
			else {
				gl_FragColor = mix(c1, c2, float(iters) / float(detail));
			}
		}
	`;

	const positions = [
	  -1.0, -1.0,
	  -1.0,  1.0,
	   1.0, -1.0,
	   1.0,  1.0,
	];

	let canvas, gl, program;

	let zoom = 3;

	window.addEventListener("load", init);
	window.addEventListener("resize", render);

	window.addEventListener("load", function() {
		canvas = document.getElementById("content");
		
		canvas.addEventListener("pointerdown", () => {
			console.log("down!");
		});

		canvas.addEventListener("pointerup", () => {
			console.log("up!");
		});

		canvas.addEventListener("pointerleave", () => {
			console.log("leave!");
		});
	});

	function init() {
		canvas = document.getElementById("content");
		gl = canvas.getContext("webgl");
		gl.clearColor(1, 1, 1, 0);

		/************************************
		 * GL Shader Compilation & Linking. *
		 ************************************/	
		const vs = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vs, vertexShader);
		gl.compileShader(vs);

		if ( ! gl.getShaderParameter(vs, gl.COMPILE_STATUS) ) {
			alert( `Vertex Shader: "${gl.getShaderInfoLog(vs)}"` );
			gl.deleteShader(vs);
		}

		const fs = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fs, fragmentShader);
		gl.compileShader(fs);

		if ( ! gl.getShaderParameter(fs, gl.COMPILE_STATUS) ) {
			alert( `Fragment Shader: "${gl.getShaderInfoLog(fs)}"` );
			gl.deleteShader(fs);
		}
		
		program = gl.createProgram();
		gl.attachShader(program, vs);
		gl.attachShader(program, fs);
		gl.linkProgram(program);

		if ( ! gl.getProgramParameter(program, gl.LINK_STATUS) ) {
			alert( gl.getProgramInfoLog(program) );
		}

		/****************************
		 * Position Attribute Setup *
		 ****************************/	
		const posBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

		const p = gl.getAttribLocation(program, "renderPos");
		gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
		gl.vertexAttribPointer(p, 2, gl.FLOAT, false, 0, 0);
		gl.enableVertexAttribArray(p);

		render();
	}

	function render() {
		/*************************
		 * GL Setup              *
		 * May want to move out. *
		 *************************/
		const pixelRatio = window.devicePixelRatio || 1;
		canvas.width  = pixelRatio * canvas.clientWidth;
		canvas.height = pixelRatio * canvas.clientHeight;
		gl.viewport(0, 0, canvas.width, canvas.height);

		/**********************************
		 * Matrix Transform Uniform Setup *
		 * May need its own function.     *
		 **********************************/
		const [scaleX, scaleY] = canvas.width > canvas.height
							   ? [zoom * (canvas.width / canvas.height), zoom]
							   : [zoom, zoom * (canvas.height / canvas.width)];
		let matrix = [ // FIXME: Will want to scale & shift based on user input (not static)
		  scaleX , 0      , 0,
		  0      , scaleY , 0,
		  0      , 0      , 1
		];

		const m = gl.getUniformLocation(program, "transform");
		gl.useProgram(program);
		gl.uniformMatrix3fv(m, false, matrix);

		/*****************************
		 * Actually render the scene *
		 *****************************/
		gl.clear(gl.COLOR_BUFFER_BIT);
		gl.useProgram(program);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	}

</script>

<style>
	#content {
		width: 100%;
		height: 100%;
		position: absolute;
	}

	body {
		margin: 0;
	}
</style>
</head>

<body>
	<canvas id="content"></canvas>
</body>
</html>