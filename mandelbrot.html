<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mandelbrot</title>

<script type="text/javascript">
	const vertexShader = `
		attribute vec2 renderPos;
		uniform mat3 transform;
		varying vec2 complexPos;

		void main() {
			complexPos = vec2(transform * vec3(renderPos, 1));
			gl_Position = vec4(renderPos, 0, 1);
		}
	`;

	const fragmentShader = `
		precision highp float;

		varying vec2 complexPos;
		const int detail = 20;
		const vec4 black = vec4(0, 0, 0, 1);
		const vec4 c1 = vec4(0, 0, 0, 1);
		const vec4 c2 = vec4(1, 1, 1, 1);

		void main() {
			float x = complexPos.x;
			float y = complexPos.y;

			int iters;
			for (int i = 0; i < detail; i++) {
				if (sqrt(x*x + y*y) > 2.0) {
					iters = i;
				  break;
				}

				float nextX = x*x - y*y + complexPos.x;
				y = 2.0*x*y + complexPos.y;
				x = nextX;
			}

			if (iters == detail) {
				gl_FragColor = black;
			}
			else {
				gl_FragColor = mix(c1, c2, float(iters) / float(detail));
			}
		}
	`;

	const positions = [
	  -1.0, -1.0,
	  -1.0,  1.0,
	   1.0, -1.0,
	   1.0,  1.0,
	];

	let canvas, gl, program;

	let zoom = 3;
	let x = 0, y = 0;
	let dragStart = null;

	window.addEventListener("load", init);
	window.addEventListener("resize", render);

	window.addEventListener("load", function() {
		canvas = document.getElementById("content");
		
		canvas.addEventListener("pointerdown", e => {
			console.log("down!");
			dragStart = mapVW([e.offsetX, e.offsetY]);
		});

		canvas.addEventListener("pointermove", e => {
			if (!dragStart) return;

			[startX, startY] = dragStart;
			const [currX, currY] = mapVW([e.offsetX, e.offsetY]);
			// Move frame s.t. dragStart is under the clicked point
			x += startX - currX; y += startY - currY;

			render();
		});

		canvas.addEventListener("pointerup", () => {
			console.log("up!");
			dragStart = null;
		});

		canvas.addEventListener("pointerleave", () => {
			console.log("leave!");
			dragStart = null;
		});

		canvas.addEventListener("wheel", e => {
			const zoomRatio = Math.pow(4/3, e.deltaY / 100);
			// p is the world-coordinate corresponding to the pointer's position.
			const [pX, pY] = mapVW([e.offsetX, e.offsetY]);

			// v is the vector from the window's position to p.
			// When the window is zoomed, we want p to remain fixed under the pointer, so we
			// move the window according to the equation: delta = v - zoom*v = (1 - zoom)*v
			const [vX, vY] = [pX - x, pY - y];
			const [dx, dy] = [(1 - zoomRatio)*vX, (1 - zoomRatio)*vY];

			x += dx; y += dy;
			zoom *= zoomRatio
			render();
		});
	});

	/**
	 * Map some positon from view-space (relative to the top-left corner of the canvas) to world-space.
	 */
	function mapVW(position) {
		const [X, Y] = position;
		const minDim = canvas.width < canvas.height ? canvas.width : canvas.height;
		return [(X - canvas.width / 2) / minDim * zoom * 2 + x,
		        -(Y - canvas.height / 2) / minDim * zoom * 2 + y];
	}

	function set(X, Y, Z) {
		x = X;
		y = Y;
		zoom = Z;
		render();
	}

	function init() {
		canvas = document.getElementById("content");
		gl = canvas.getContext("webgl");
		gl.clearColor(1, 1, 1, 0);

		/************************************
		 * GL Shader Compilation & Linking. *
		 ************************************/	
		const vs = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vs, vertexShader);
		gl.compileShader(vs);

		if ( ! gl.getShaderParameter(vs, gl.COMPILE_STATUS) ) {
			alert( `Vertex Shader: "${gl.getShaderInfoLog(vs)}"` );
			gl.deleteShader(vs);
		}

		const fs = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fs, fragmentShader);
		gl.compileShader(fs);

		if ( ! gl.getShaderParameter(fs, gl.COMPILE_STATUS) ) {
			alert( `Fragment Shader: "${gl.getShaderInfoLog(fs)}"` );
			gl.deleteShader(fs);
		}
		
		program = gl.createProgram();
		gl.attachShader(program, vs);
		gl.attachShader(program, fs);
		gl.linkProgram(program);

		if ( ! gl.getProgramParameter(program, gl.LINK_STATUS) ) {
			alert( gl.getProgramInfoLog(program) );
		}

		/****************************
		 * Position Attribute Setup *
		 ****************************/	
		const posBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

		const p = gl.getAttribLocation(program, "renderPos");
		gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
		gl.vertexAttribPointer(p, 2, gl.FLOAT, false, 0, 0);
		gl.enableVertexAttribArray(p);

		render();
	}

	function render() {
		/*************************
		 * GL Setup              *
		 * May want to move out. *
		 *************************/
		const pixelRatio = window.devicePixelRatio || 1;
		canvas.width  = pixelRatio * canvas.clientWidth;
		canvas.height = pixelRatio * canvas.clientHeight;
		gl.viewport(0, 0, canvas.width, canvas.height);

		/**********************************
		 * Matrix Transform Uniform Setup *
		 * May need its own function.     *
		 **********************************/
		const [scaleX, scaleY] = canvas.width > canvas.height
							   ? [zoom * (canvas.width / canvas.height), zoom]
							   : [zoom, zoom * (canvas.height / canvas.width)];
		let matrix = [
		  scaleX , 0      , 0,
		  0      , scaleY , 0,
		  x      , y      , 1
		];

		const m = gl.getUniformLocation(program, "transform");
		gl.useProgram(program);
		gl.uniformMatrix3fv(m, false, matrix);

		/*****************************
		 * Actually render the scene *
		 *****************************/
		gl.clear(gl.COLOR_BUFFER_BIT);
		gl.useProgram(program);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	}

</script>

<style>
	#content {
		position: absolute;
		width: 100%;
		height: 100%;
	}

	#controls {
		position: absolute;
		top: 1em;
		right: 1em;
	}

	body {
		margin: 0;
	}

</style>
</head>

<body>
	<canvas id="content"></canvas>
	<div id="controls">
		<button onclick="{zoom *= 3/4; render();}">+</button>
		<button onclick="{zoom *= 4/3; render();}">-</button>
	</div>
</body>
</html>